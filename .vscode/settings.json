{
  "github.copilot.chat.welcomeMessage": "never",
  "github.copilot.enable": {
    "*": true,
    "plaintext": false,
    "markdown": true,
    "scminput": false
  },
  "github.copilot.editor.enableAutoCompletions": true,
  "github.copilot.chat.experimental.codeGeneration.instructions": [
    {
      "text": "# ObjectIO S3-Compatible Storage System Development Guidelines\n\n## Project Context\n- Building a high-performance S3-compatible object storage system in Rust\n- Backend: Axum web framework + SurrealDB + Redis caching\n- Frontend: Leptos WebAssembly reactive framework\n- Target: AWS S3 API compatibility with enterprise-grade features\n\n## Architecture Principles\n1. **Performance First**: Use async/await, minimize allocations, leverage Rust's zero-cost abstractions\n2. **S3 Compatibility**: Strict AWS S3 API compliance, including error responses and headers\n3. **Modular Design**: Clear separation between storage backends, authentication, and API layers\n4. **Security**: Implement AWS Signature Version 4, proper access controls, and audit logging\n5. **Observability**: Comprehensive metrics, tracing, and structured logging\n\n## Code Style Guidelines\n\n### Rust Backend (Axum + SurrealDB)\n- Use `tokio` for async runtime, prefer `async/await` over manual Future implementations\n- Implement proper error handling with `anyhow` or custom error types\n- Use `serde` for serialization with proper field validation\n- Follow Rust naming conventions: snake_case for functions/variables, PascalCase for types\n- Add comprehensive documentation with `///` doc comments\n- Use `tracing` for structured logging with appropriate span contexts\n- Implement proper resource cleanup and connection pooling\n\n### Frontend (Leptos WebAssembly)\n- Use reactive signals for state management\n- Implement proper error boundaries and loading states\n- Follow component composition patterns\n- Use CSS modules or styled-components for styling\n- Implement accessibility features (ARIA labels, keyboard navigation)\n- Optimize for WebAssembly bundle size\n\n### Database (SurrealDB)\n- Use parameterized queries to prevent injection attacks\n- Implement proper indexing for performance\n- Follow schema versioning and migration patterns\n- Use transactions for data consistency\n- Implement proper connection pooling and retry logic\n\n## Current Sprint Focus\n**Sprint 1: Core Foundation (Priority Issues)**\n- CORE-001: Project structure setup (1 day)\n- CORE-002: SurrealDB setup and schema (2 days)\n- CORE-003: Axum HTTP server with middleware (1.5 days)\n- TEST-001: Testing infrastructure setup (2 days)\n\n## Code Generation Preferences\n\n### When writing Rust code:\n- Always include proper error handling with `Result<T, E>`\n- Use `#[derive(Debug, Clone, Serialize, Deserialize)]` for data structures\n- Implement `Display` and `Error` traits for custom error types\n- Add `#[tokio::test]` for async test functions\n- Include comprehensive doc comments with examples\n- Use `tracing::instrument` for function tracing\n- Implement proper validation for input data\n\n### When writing Leptos components:\n- Use `#[component]` macro for reactive components\n- Implement proper prop validation and defaults\n- Use `create_signal()` for reactive state\n- Include proper error handling with `ErrorBoundary`\n- Add loading states for async operations\n- Implement proper event handlers with `on:click` syntax\n\n### When writing tests:\n- Use descriptive test names that explain the scenario\n- Follow Given-When-Then pattern in test structure\n- Include both positive and negative test cases\n- Use `rstest` for parameterized tests\n- Mock external dependencies properly\n- Include integration tests for API endpoints\n\n### When implementing S3 API endpoints:\n- Follow AWS S3 API specification exactly\n- Implement proper HTTP status codes and error responses\n- Include all required and optional headers\n- Support both path-style and virtual-hosted-style requests\n- Implement proper content-type detection\n- Add comprehensive request validation\n\n## Security Requirements\n- Always validate and sanitize user input\n- Implement proper authentication and authorization\n- Use secure random number generation for keys\n- Follow principle of least privilege\n- Log security-relevant events for audit\n- Implement rate limiting and DDoS protection\n\n## Performance Requirements\n- Target sub-100ms response times for object operations\n- Implement proper caching strategies\n- Use connection pooling for database and Redis\n- Optimize memory usage and avoid unnecessary allocations\n- Implement proper backpressure handling\n- Use streaming for large file operations\n\n## Development Workflow\n1. Create feature branch from main\n2. Implement with comprehensive tests\n3. Run `cargo fmt`, `cargo clippy`, and `cargo test`\n4. Update documentation and API specs\n5. Create PR with detailed description\n6. Ensure CI/CD pipeline passes\n7. Require code review before merge\n\n## Common Patterns to Follow\n\n### Error Handling Pattern:\n```rust\n#[derive(Debug, thiserror::Error)]\npub enum StorageError {\n    #[error(\"Object not found: {key}\")]\n    ObjectNotFound { key: String },\n    #[error(\"Database error: {0}\")]\n    Database(#[from] surrealdb::Error),\n    #[error(\"IO error: {0}\")]\n    Io(#[from] std::io::Error),\n}\n```\n\n### API Handler Pattern:\n```rust\n#[tracing::instrument(skip(state))]\npub async fn get_object(\n    Path((bucket, key)): Path<(String, String)>,\n    State(state): State<AppState>,\n) -> Result<impl IntoResponse, ApiError> {\n    // Implementation\n}\n```\n\n### Database Operation Pattern:\n```rust\n#[tracing::instrument(skip(db))]\npub async fn create_bucket(\n    db: &Database,\n    bucket: &BucketInfo,\n) -> Result<(), StorageError> {\n    // Implementation with proper error handling\n}\n```\n\n## Technologies and Dependencies\n- **Backend**: axum, tokio, surrealdb, redis, serde, tracing\n- **Frontend**: leptos, wasm-bindgen, web-sys\n- **Testing**: tokio-test, rstest, criterion (for benchmarks)\n- **Monitoring**: prometheus, opentelemetry\n- **Build**: cargo, wasm-pack, trunk (for frontend)\n\n## Remember:\n- Keep time estimates conservative (current estimates include buffers)\n- Focus on MVP features first, extensibility second\n- Maintain strict AWS S3 API compatibility\n- Write code that is maintainable and well-documented\n- Prioritize security and performance from the start"
    }
  ],
  "github.copilot.chat.experimental.codeGeneration.instructions.enabled": true,
  "rust-analyzer.checkOnSave.command": "clippy",
  "rust-analyzer.cargo.features": "all",
  "rust-analyzer.procMacro.enable": true,
  "editor.formatOnSave": true,
  "editor.codeActionsOnSave": {
    "source.fixAll": "explicit",
    "source.organizeImports": "explicit"
  },
  "[rust]": {
    "editor.defaultFormatter": "esbenp.prettier-vscode",
    "editor.tabSize": 4,
    "editor.insertSpaces": true
  },
  "[toml]": {
    "editor.defaultFormatter": "tamasfe.even-better-toml"
  },
  "[typescript]": {
    "editor.defaultFormatter": "esbenp.prettier-vscode"
  },
  "[javascript]": {
    "editor.defaultFormatter": "esbenp.prettier-vscode"
  },
  "[json]": {
    "editor.defaultFormatter": "esbenp.prettier-vscode"
  },
  "[markdown]": {
    "editor.defaultFormatter": "esbenp.prettier-vscode",
    "editor.wordWrap": "on"
  },
  "files.watcherExclude": {
    "**/target/**": true,
    "**/node_modules/**": true,
    "**/.git/**": true,
    "**/pkg/**": true,
    "**/dist/**": true
  },
  "search.exclude": {
    "**/target": true,
    "**/node_modules": true,
    "**/pkg": true,
    "**/dist": true
  },
  "rust-analyzer.assist.importGranularity": "module",
  "rust-analyzer.completion.autoimport.enable": true,
  "rust-analyzer.inlayHints.typeHints.enable": true,
  "rust-analyzer.inlayHints.parameterHints.enable": true,
  "rust-analyzer.lens.enable": true,
  "rust-analyzer.lens.methodReferences": true,
  "rust-analyzer.lens.references": true,
  "extensions.ignoreRecommendations": false,
  "workbench.settings.applyToAllProfiles": [
    "github.copilot.chat.experimental.codeGeneration.instructions"
  ]
}
